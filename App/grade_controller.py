from django.shortcuts import render, render_to_response
from django.http import *
from django.views.decorators.csrf import csrf_exempt
from django.forms.models import model_to_dict
from django.conf import settings
import json, os, time

from django.core.exceptions import ObjectDoesNotExist

from App.models import *
import App.grader

def evaluate(expected_points, submitted_points):
	# Return grade/feedback by comparing certain statistics
	# generated by methods that take the stroke points as a parameter

	# GRADING POLICY
	#
	# Character Grade: 40%
	# - Stroke Count: 20% (all or nothing)
	# - Dimension Ratio: 20%
	# - Number of Multiple Intersections: 20%
	# - Relative Location of Multple Intersections: 20%
	# - Relative Location of COG: 20%
	#
	# - If there are no intersections,
	#    eliminate Relative Location of Multiple Intersections
	#    and make everything valued at 25%
	#
	#
	# Strokes Grade: 60% (Following Grades per Stroke)
	# - Dimension Ratio: 12.5%
	# - Number of Self Intersections: 12.5%
	# - Relative Location of Self Intersections: 12.5%
	# - Relative Location of Stroke Range: 12.5%
	# - Relative Location of Endpoints: 12.5%
	# - Relative Location of Stroke COG: 12.5%
	# - Stroke Shape (Using Derivatives): 25%
	# 
	# - If there are no intersections,
	#    eliminate Relative Location of Self Intersections
	#    and make everything valued at 15%
	#    except for Stroke Shape (stays the same at 25%)

	result = {
		"data" : {},
		"character-grade" : 0.0,
		"character-weight" : 0.4,
		"strokes-grade" : 0.0,
		"strokes-weight" : 0.6,
		"feedback" : {}
	}

	# Stroke Count
	expected_stroke_count = grader.get_stroke_count(expected_points)
	submitted_stroke_count = grader.get_stroke_count(submitted_points)
	if expected_stroke_count != submitted_stroke_count:
		result["feedback"] = {
			"stroke-count-difference" : submitted_stroke_count - expected_stroke_count
		}
		return result
	else:
		result["character-grade"] += 0.25
	
	# Overall Character COG
	expected_COG = grader.calculate_COG(expected_points)
	submitted_COG = grader.calculate_COG(submitted_points)

	# Stroke COGs
	expected_stroke_COGs = grader.calculate_stroke_COGs(expected_points)
	submitted_stroke_COGs = grader.calculate_stroke_COGs(submitted_points)

	# Character Range
	expected_range = grader.calculate_range(expected_points)
	submitted_range = grader.calculate_range(submitted_points)

	[expected_x_min, expected_y_min, expected_x_max, expected_y_max] = expected_range
	[submitted_x_min, submitted_y_min, submitted_x_max, submitted_y_max] = submitted_range

	expected_width = expected_x_max - expected_x_min
	submitted_width = submitted_x_max - submitted_x_min
	expected_height = expected_y_max - expected_y_min
	submitted_height = submitted_y_max - submitted_y_min
	expected_ratio = expected_width / float(expected_height)
	submitted_ratio = submitted_width / float(submitted_height)

	# Stroke Ranges
	expected_stroke_ranges = grader.calculate_stroke_ranges(expected_points)
	submitted_stroke_ranges = grader.calculate_stroke_ranges(submitted_points)
	for stroke_range in expected_stroke_ranges:
		# TODO
		continue

	result["data"] = {
		"expected_ratio" : expected_ratio,
		"submitted_ratio" : submitted_ratio
	}

	return result

@csrf_exempt
def student_submit(request):
	# Get character ID and submitted points from the request and evaluate
	try:
		if request.method == "POST":
			data = json.loads(request.body)
			character = Character.objects.get(id=data["character"]["character-id"])
			expected_points = json.loads(character.points)
			submitted_points = data["strokes"]
			results = evaluate(expected_points, submitted_points)
			response = {
				"results" : results
			}
			return HttpResponse(json.dumps(response), content_type="application/json")
		else:
			return HttpResponseNotAllowed(['POST'])
	except ObjectDoesNotExist:
		return HttpResponse(status=404)
	except Exception, e:
		# TODO: Error-Handling
		raise