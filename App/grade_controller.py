from django.shortcuts import render, render_to_response
from django.http import *
from django.views.decorators.csrf import csrf_exempt
from django.forms.models import model_to_dict
from django.conf import settings
import json, os, time

from django.core.exceptions import ObjectDoesNotExist

from App.models import *
import App.grader

def evaluate(expected_points, submitted_points):
	# Return grade/feedback by comparing certain statistics
	# generated by methods that take the stroke points as a parameter

	# GRADING POLICY
	#
	# Character Grade: 40%
	# - Stroke Count: 20% (all or nothing) DONE
	# - Dimension Ratio: 20% DONE
	# - Number of Multiple Intersections: 20% DONE
	# - Relative Location of Multple Intersections: 20% (wrt two stroke ranges -> TODO)
	# - Relative Location of COG: 20% DONE (wrt character range) (NECESSARY???)
	#
	# - If there are no intersections,
	#    eliminate Relative Location of Multiple Intersections
	#    and make everything valued at 25% (TODO)
	#
	#
	# Strokes Grade: 60% (Following Grades per Stroke)
	# - Dimension Ratio: 12.5% (TODO)
	# - Number of Self Intersections: 12.5% (TODO)
	# - Relative Location of Self Intersections: 12.5% (wrt stroke range) (TODO)
	# - Relative Location of Stroke Range: 12.5% (wrt character range) (TODO)
	# - Relative Location of Endpoints: 12.5% (wrt stroke range) (TODO)
	# - Relative Location of Stroke COG: 12.5% ??? (wrt stroke range) (TODO)
	# - Stroke Shape (Using Derivatives): 25% TODO: Difficult
	# 
	# - If there are no intersections,
	#    eliminate Relative Location of Self Intersections
	#    and make everything valued at 15%
	#    except for Stroke Shape (stays the same at 25%)

	# TODO: PUT ALL SCORING WEIGHTS AS CONSTANTS AND PUT IN RESULT

	result = {
		"data" : {},
		"character-grade" : 0.0,
		"character-grade-data" : {},
		"strokes-grade" : 0.0,
		"strokes-grade-data" : {},
		"feedback" : {}
	}


	# Stroke Count
	expected_stroke_count = grader.get_stroke_count(expected_points)
	submitted_stroke_count = grader.get_stroke_count(submitted_points)
	result["feedback"]["stroke-count-difference"] = submitted_stroke_count - expected_stroke_count
	if expected_stroke_count != submitted_stroke_count:
		result["character-grade-data"]["stroke-count"] = 0
		return result
	else:
		result["character-grade"] += 0.2
		result["character-grade-data"]["stroke-count"] = 1


	# Character Range and Dimension Ratio
	expected_range = grader.calculate_range(expected_points)
	submitted_range = grader.calculate_range(submitted_points)
	[expected_x_min, expected_y_min, expected_x_max, expected_y_max] = expected_range
	[submitted_x_min, submitted_y_min, submitted_x_max, submitted_y_max] = submitted_range
	expected_width = expected_x_max - expected_x_min
	submitted_width = submitted_x_max - submitted_x_min
	expected_height = expected_y_max - expected_y_min
	submitted_height = submitted_y_max - submitted_y_min
	expected_ratio = expected_width / float(expected_height)
	submitted_ratio = submitted_width / float(submitted_height)
	ratio_offset = (submitted_ratio / expected_ratio) - 1.0 # 0.5-2.0
	if ratio_offset > -0.1 and ratio_offset < 0.20:
		# Allowable
		result["character-grade"] += 0.2
		result["character-grade-data"]["character-dimension-ratio"] = 1
		result["feedback"]["character-dimension-ratio"] = "Acceptable"
	else:
		if ratio_offset < -0.1:
			# smaller ratio
			ratio_score = 1 - ((min(-1*ratio_offset, 0.5) - 0.1) / 0.4)
			result["feedback"]["character-dimension-ratio"] = "Long"
		elif ratio_offset > 0.20:
			# greater ratio
			ratio_score = 1 - ((min(ratio_offset, 1.0) - 0.2) / 0.8)
			result["feedback"]["character-dimension-ratio"] = "Wide"
		else:
			# unhandled???
			ratio_score = -1
		result["character-grade"] += ratio_score * 0.2
		result["character-grade-data"]["character-dimension-ratio"] = ratio_score
	

	# Overall Character COG
	# TODO: is this NECESSARY???
	expected_COG = grader.calculate_COG(expected_points)
	submitted_COG = grader.calculate_COG(submitted_points)
	expected_COGx_relative = (expected_COG[0] - expected_x_min) / expected_width
	expected_COGy_relative = (expected_COG[1] - expected_y_min) / expected_height
	submitted_COGx_relative = (submitted_COG[0] - submitted_x_min) / submitted_width
	submitted_COGy_relative = (submitted_COG[1] - submitted_y_min) / submitted_height
	COGx_ratio_offset = (submitted_COGx_relative / expected_COGx_relative) - 1
	COGy_ratio_offset = (submitted_COGy_relative / expected_COGy_relative) - 1
	if COGx_ratio_offset > -0.1 and COGx_ratio_offset < 0.20:
		# Allowable
		result["character-grade"] += 0.1
		result["character-grade-data"]["character-COG-x"] = 1
		result["feedback"]["character-COG-x"] = "Acceptable"
	else:
		if COGx_ratio_offset < -0.1:
			# too far left
			COGx_ratio_score = 1 - ((min(-1*COGx_ratio_offset, 0.5) - 0.1) / 0.4)
			result["feedback"]["character-COG-x"] = "Left"
		elif COGx_ratio_offset > 0.20:
			# too far right
			COGx_ratio_score = 1 - ((min(COGx_ratio_offset, 1.0) - 0.2) / 0.8)
			result["feedback"]["character-COG-x"] = "Right"
		else:
			# unhandled???
			COGx_ratio_score = -1
		result["character-grade"] += COGx_ratio_score * 0.1
		result["character-grade-data"]["character-COG-x"] = COGx_ratio_score
	if COGy_ratio_offset > -0.1 and COGy_ratio_offset < 0.20:
		# Allowable
		result["character-grade"] += 0.1
		result["character-grade-data"]["character-COG-y"] = 1
		result["feedback"]["character-COG-y"] = "Acceptable"
	else:
		if COGy_ratio_offset < -0.1:
			# too far left
			COGy_ratio_score = 1 - ((min(-1*COGy_ratio_offset, 0.5) - 0.1) / 0.4)
			result["feedback"]["character-COG-y"] = "Low"
		elif COGy_ratio_offset > 0.20:
			# too far right
			COGy_ratio_score = 1 - ((min(COGy_ratio_offset, 1.0) - 0.2) / 0.8)
			result["feedback"]["character-COG-y"] = "High"
		else:
			# unhandled???
			COGy_ratio_score = -1
		result["character-grade"] += COGy_ratio_score * 0.1
		result["character-grade-data"]["character-COG-y"] = COGy_ratio_score

	# Multiple-Stroke Intersections (and Relative Location)
	expected_intersections = grader.calculate_intersections(expected_points)
	submitted_intersections = grader.calculate_intersections(submitted_points)
	num_expected_multi_intersections = len(expected_intersections["multiple"])
	num_submitted_multi_intersections = len(submitted_intersections["multiple"])
	result["feedback"]["multi-intersections-difference"] = num_submitted_multi_intersections - num_expected_multi_intersections
	if num_expected_multi_intersections == num_submitted_multi_intersections:
		# matching
		result["character-grade"] += 0.2
		result["character-grade-data"]["multi-intersections"] = 1
		# intersection locations
		n_mi = len(expected_intersections["multiple"])
		result["feedback"]["character-multiple-intersection-position-x"] = []
		result["feedback"]["character-multiple-intersection-position-y"] = []
		result["character-grade-data"]["character-multiple-intersection-position-x"] = []
		result["character-grade-data"]["character-multiple-intersection-position-y"] = []
		for i in range(n_mi):
			# TODO: Should offset be relative to intersecting characters??? YES
			e_m_intersection = expected_intersections["multiple"][i]
			s_m_intersection = submitted_intersections["multiple"][i]
			[emix, emiy] = e_m_intersection["point"]
			[smix, smiy] = s_m_intersection["point"]
			emix_ratio = (emix - expected_x_min) / expected_width
			emiy_ratio = (emiy - expected_y_min) / expected_height
			smix_ratio = (smix - submitted_x_min) / submitted_width
			smiy_ratio = (smiy - submitted_y_min) / submitted_height
			mix_ratio_offset = (smix_ratio / emix_ratio) - 1
			miy_ratio_offset = (smiy_ratio / emiy_ratio) - 1
			if mix_ratio_offset > -0.1 and mix_ratio_offset < 0.20:
				# Allowable
				mix_ratio_score = 1
				result["feedback"]["character-multiple-intersection-position-x"].append("Acceptable")
			else:
				if mix_ratio_offset < -0.1:
					# smaller ratio
					mix_ratio_score = 1 - ((min(-1*mix_ratio_offset, 0.5) - 0.1) / 0.4)
					result["feedback"]["character-multiple-intersection-position-x"].append("Left")
				elif mix_ratio_offset > 0.20:
					# greater ratio
					mix_ratio_score = 1 - ((min(mix_ratio_offset, 1.0) - 0.2) / 0.8)
					result["feedback"]["character-multiple-intersection-position-x"].append("Right")
				else:
					# unhandled???
					mix_ratio_score = -1
			result["character-grade"] += mix_ratio_score * (0.1 / n_mi)
			result["character-grade-data"]["character-multiple-intersection-position-x"].append(mix_ratio_score)

			# TODO: Should offset be relative to intersecting characters???
			if miy_ratio_offset > -0.1 and miy_ratio_offset < 0.20:
				# Allowable
				miy_ratio_score = 1
				result["feedback"]["character-multiple-intersection-position-y"].append("Acceptable")
			else:
				if miy_ratio_offset < -0.1:
					# smaller ratio
					miy_ratio_score = 1 - ((min(-1*miy_ratio_offset, 0.5) - 0.1) / 0.4)
					result["feedback"]["character-multiple-intersection-position-y"].append("Left")
				elif mix_ratio_offset > 0.20:
					# greater ratio
					mix_ratio_score = 1 - ((min(mix_ratio_offset, 1.0) - 0.2) / 0.8)
					result["feedback"]["character-multiple-intersection-position-y"].append("Right")
				else:
					# unhandled???
					miy_ratio_score = -1
			result["character-grade"] += miy_ratio_score * (0.1 / n_mi)
			result["character-grade-data"]["character-multiple-intersection-position-y"].append(miy_ratio_score)
			
	else:
		result["character-grade-data"]["multi-intersections"] = 0
		result["character-grade-data"]["multi-intersection-positioning"] = 0
		

	# Stroke COGs
	expected_stroke_COGs = grader.calculate_stroke_COGs(expected_points)
	submitted_stroke_COGs = grader.calculate_stroke_COGs(submitted_points)
	

	# Stroke Ranges
	expected_stroke_ranges = grader.calculate_stroke_ranges(expected_points)
	submitted_stroke_ranges = grader.calculate_stroke_ranges(submitted_points)
	for stroke_range in expected_stroke_ranges:
		# TODO
		continue

	# DEBUGGING PURPOSES
	result["data"] = {
		"expected_ratio" : expected_ratio,
		"submitted_ratio" : submitted_ratio
	}

	return result

@csrf_exempt
def student_submit(request):
	# Get character ID and submitted points from the request and evaluate
	try:
		if request.method == "POST":
			data = json.loads(request.body)
			character = Character.objects.get(id=data["character"]["character-id"])
			expected_points = json.loads(character.points)
			submitted_points = data["strokes"]
			results = evaluate(expected_points, submitted_points)
			response = {
				"results" : results
			}
			return HttpResponse(json.dumps(response), content_type="application/json")
		else:
			return HttpResponseNotAllowed(['POST'])
	except ObjectDoesNotExist:
		return HttpResponse(status=404)
	except Exception, e:
		# TODO: Error-Handling
		raise
